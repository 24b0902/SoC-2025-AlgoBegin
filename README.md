# SoC-2025-AlgoBegin

üìå Overview
This repository/document serves as a summary and reflection of everything I have learned in the AlgoBegin: First Steps into Competitive Programming summer program. Over the course of several weeks, I focused on mastering Python, understanding core algorithms, and exploring foundational data structures and graph-based problem solving.

üóÇÔ∏è Weekly Progress & Topics Covered

‚úÖ Week 1: Python Fundamentals + Libraries
Built a strong foundation in core Python.

Learned and practiced using:

NumPy for numerical computing.

Pandas for data manipulation and analysis.

Matplotlib for basic data visualization.

Wrote scripts for:

Array and matrix operations.

DataFrame creation, filtering, grouping.

Plotting graphs and charts.

‚úÖ Week 2: Python Data Structures
Studied and implemented:

Lists, Tuples, Sets, Dictionaries.

Stacks, Queues, Deques using collections.

Hands-on practice with:

defaultdict, deque, Counter.

Nested data structures and their use-cases.

Time and space complexity of each structure.

‚úÖ Week 3: Sorting & Searching Algorithms
Implemented and compared:

Bubble Sort, Selection Sort, Insertion Sort.

Merge Sort, Quick Sort (with recursion).

Studied Searching Algorithms:

Linear Search

Binary Search (iterative and recursive)

Learned how to analyze:

Time and Space complexity using Big-O.

‚úÖ Week 4: Recursion, Greedy & Backtracking
Deep-dived into:

Recursive function design.

Base cases, stack memory behavior.

Implemented:

Factorial, Fibonacci, Tower of Hanoi.

Solved problems with:

Greedy techniques (e.g., activity selection, coin change).

Backtracking (e.g., N-Queens, Sudoku Solver, Maze path finding).

‚úÖ Week 5: Graph Algorithms
Represented graphs using:

Adjacency list and adjacency matrix.

defaultdict(list) for dynamic storage.

Implemented traversal algorithms:

BFS using queue (deque).

DFS using recursion and stack.

Additional Concepts:

Connected components.

Handling cycles and disconnected graphs.

üß† Key Learnings
Built a solid understanding of Python as a language for problem solving.

Learned how to break problems into subproblems using recursive thinking.

Developed intuition for choosing the right data structures and algorithms based on constraints.

Understood the role of graph algorithms in competitive programming and real-world scenarios.

